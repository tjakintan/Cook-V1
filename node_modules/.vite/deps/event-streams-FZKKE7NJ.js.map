{
  "version": 3,
  "sources": ["../../@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],
  "sourcesContent": ["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
